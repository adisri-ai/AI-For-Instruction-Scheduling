# -*- coding: utf-8 -*-
"""instruction scheduling full project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ufGgTjiB9oUAawUNFrJKWd_3HwQNcPi
"""

# training data generation and creating control flow flow graph

"""
Instruction Scheduling Project — Multi-Personality Data Generator & CFG Builder
-------------------------------------------------------------------------------

This script performs:
  1. Synthetic C++-like code generation with multiple "programmer personalities"
  2. Control Flow Graph (CFG) construction for each generated code
  3. Dataset creation (data.csv) containing:
         code_str | labels
     in the current working directory

Each function is carefully documented with detailed comments.
"""
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
import random
import csv
from typing import List, Tuple, Dict

# ---------------------------------------------------------------------
# Step 1: Personality-based code generation
# ---------------------------------------------------------------------

def _rand_var():
    """Return a random single-letter variable name."""
    return random.choice([chr(c) for c in range(ord("a"), ord("z") + 1)])


def _assign_statement(var: str = None, val: int = None) -> str:
    """Generate a single assignment statement like 'x = 4'."""
    if var is None:
        var = _rand_var()
    if val is None:
        val = random.randint(0, 5)
    return f"{var} = {val}"


def _if_block_chain(max_chain=3) -> Tuple[str, list[int]]:
    """
    Generate a random if–else-if–else block chain and corresponding labels.
    Labels represent whether each condition evaluates True (1) or False (0).
    """
    var = _rand_var()
    val = random.randint(0, 5)
    pre = f"{var} = {val}\n"
    chain_len = random.randint(1, max_chain)

    parts, labels = [], []
    for i in range(chain_len):
        c = random.randint(0, 5)
        op = random.choice(["<", ">", "==", "<=", ">="])
        cond = f"if({var} {op} {c})" if i == 0 else f"else if({var} {op} {c})"
        expr = f"{val} {op} {c}"
        try:
            label = 1 if eval(expr) else 0
        except Exception:
            label = 0
        labels.append(label)
        parts.append(cond + " {\n    " + _assign_statement() + "\n}")
    # Optional else block
    if random.choice([True, False]):
        parts.append("else {\n    " + _assign_statement() + "\n}")
    return pre + "\n".join(parts), labels


def _for_block() -> Tuple[str, int]:
    """Generate a small for-loop block and a binary label (loop executed or not)."""
    iter_count = random.randint(0, 3)
    loop = f"for(int i=0; i<{iter_count}; i++) {{\n    {_assign_statement()}\n}}"
    label = 1 if iter_count > 0 else 0
    return loop, label


# ---------------------------------------------------------------------
# Step 2: Personalities — define 4 programmer styles
# ---------------------------------------------------------------------

def _generate_personality_code(personality: str,
                               min_statements=3,
                               max_statements=7) -> Tuple[str, list[int]]:
    """
    Generate code influenced by a specific 'personality' (style).
    Each personality has its own statistical preferences.
    """
    stmts, labels = [], []

    if personality == "A":  # Compact coder
        choices = ["assign"] * 5 + ["if"] * 2 + ["for"]
    elif personality == "B":  # Verbose coder
        choices = ["assign"] * 3 + ["if"] * 3 + ["for"] * 2
    elif personality == "C":  # Experimental coder
        choices = ["assign"] * 2 + ["if"] * 3 + ["for"] * 3
    else:  # D — Structured coder (balanced)
        choices = ["assign"] * 4 + ["if"] * 2 + ["for"] * 2

    stmt_count = random.randint(min_statements, max_statements)
    for _ in range(stmt_count):
        choice = random.choice(choices)
        if choice == "assign":
            stmts.append(_assign_statement())
        elif choice == "if":
            chain, l = _if_block_chain()
            stmts.append(chain)
            labels.extend(l)
        else:
            loop, l = _for_block()
            stmts.append(loop)
            labels.append(l)

    stmts.append("END")  # terminal marker
    return "\n".join(stmts), labels


def generate_codes(n: int = 100,
                   personalities: List[str] = ["A", "B", "C", "D"]) -> Tuple[List[str], List[list[int]]]:
    """
    Generate 'n' random code samples by mixing multiple programmer personalities.
    Returns lists of (codes, labels).
    """
    codes, labels_list = [], []
    for _ in range(n):
        personality = random.choice(personalities)
        code, labels = _generate_personality_code(personality)
        codes.append(code)
        labels_list.append(labels)
    return codes, labels_list


# ---------------------------------------------------------------------
# Step 3: Control Flow Graph (CFG) Builder
# ---------------------------------------------------------------------

import re
import ast
from typing import List, Tuple, Dict, Any, Optional

# ... (all other code in training.py stays the same) ...


def build_cfg(code_str: str) -> Tuple[Dict[int, str], Dict[int, List[int]]]:
    """
    Build a simple, recursive control-flow-graph (CFG) from a C++-like
    code string that correctly handles nested structures.

    Returns (node_dict, edges) where:
      - node_dict[i] = node_text
      - edges is adjacency list (Dict[int, List[int]])

    This implementation follows these rules:
    1.  Each statement (assign, if, for) is a node.
    2.  An 'if' node has two edges:
        - [True]: Connects to the entry of its body block.
        - [False]: Connects to the next 'else if', 'else', or the
                   statement after the chain.
    3.  A 'for' node has two edges:
        - [Loop Body]: Connects to the entry of its body block.
        - [Loop Exit]: Connects to the statement after the loop.
    4.  The last statement(s) in a 'for' body connect back to the
        'for' header node.
    5.  All loose-end execution paths (ends of bodies, fall-throughs)
        are connected to a virtual "END" node.
    """
    lines = [ln.strip() for ln in code_str.splitlines() if ln.strip() != ""]
    node_dict: Dict[int, str] = {}
    edges: Dict[int, List[int]] = {}

    def _add_node(text: str) -> int:
        """Helper to add a new node and initialize its edge list."""
        idx = len(node_dict)
        node_dict[idx] = text
        edges[idx] = []
        return idx

    def _find_body_start(lines: List[str], i: int) -> int:
        """Find index after a header and its opening brace '{'."""
        j = i + 1
        if j < len(lines) and lines[j].startswith("{"):
            j += 1
        return j

    def _parse_block(
        start_index: int, stop_on_brace: bool
    ) -> Tuple[Optional[int], List[int], int]:
        """
        Recursively parse a block of code.

        Args:
            start_index: The line index to start parsing from.
            stop_on_brace: If True, stop when a '}' is found (for parsing
                           nested bodies).

        Returns:
            (block_entry_node, block_exit_nodes, next_line_index)
            - block_entry_node: The index of the first node in this block.
            - block_exit_nodes: List of node indices that "exit" this
                                block (e.g., last statements).
            - next_line_index: The line index after this block was parsed.
        """
        i = start_index
        block_entry_node: Optional[int] = None
        # Exits from the *previous* statement in the current sequence
        prev_statement_exits: List[int] = []

        while i < len(lines):
            ln = lines[i]

            # 1. Check for stop condition (end of a nested body)
            if stop_on_brace and ln.startswith("}"):
                return block_entry_node, prev_statement_exits, i

            # 2. Find the entry point for this new statement
            #    (This will be set differently for if/for/assign)
            current_node_index: Optional[int] = None

            # 3. Handle 'if' / 'else if' / 'else' chains
            if ln.startswith("if(") or ln.startswith("else if(") or ln.startswith("else"):
                chain_entry_node: Optional[int] = None
                # All nodes that exit the *entire* if-chain
                chain_exit_nodes: List[int] = []
                # The 'false' path of the *last* condition in the chain
                last_condition_node: Optional[int] = None

                # Loop through the 'if', 'else if', 'else' parts
                while i < len(lines):
                    part_ln = lines[i]
                    is_if = part_ln.startswith("if(")
                    is_else_if = part_ln.startswith("else if(")
                    is_else = part_ln.startswith("else") and not is_else_if

                    if not (is_if or is_else_if or is_else):
                        break  # End of chain

                    if is_if or is_else_if:
                        # --- This is an 'if' or 'else if' condition ---
                        cond_node = _add_node(part_ln)
                        if chain_entry_node is None:
                            chain_entry_node = cond_node

                        # Connect false path of *previous* condition
                        if last_condition_node is not None:
                            edges[last_condition_node].append(cond_node)

                        # Find body and recurse
                        body_start_idx = _find_body_start(lines, i)
                        (
                            body_entry,
                            body_exits,
                            body_end_idx,
                        ) = _parse_block(body_start_idx, stop_on_brace=True)

                        if body_entry is not None:
                            edges[cond_node].append(body_entry)  # True path
                        
                        chain_exit_nodes.extend(body_exits)
                        last_condition_node = cond_node
                        i = body_end_idx + 1  # Move past '}'

                    elif is_else:
                        # --- This is an 'else' block ---
                        body_start_idx = _find_body_start(lines, i)
                        (
                            body_entry,
                            body_exits,
                            body_end_idx,
                        ) = _parse_block(body_start_idx, stop_on_brace=True)

                        # Connect false path of last condition
                        if last_condition_node is not None:
                            if body_entry is not None:
                                edges[last_condition_node].append(body_entry)
                        
                        chain_exit_nodes.extend(body_exits)
                        last_condition_node = None  # 'else' consumes the false path
                        i = body_end_idx + 1
                        break  # 'else' is always the end
                
                # After the chain:
                # Set the entry node for the *whole* chain
                current_node_index = chain_entry_node

                # Connect previous statement to the start of this chain
                if current_node_index is not None:
                    for idx in prev_statement_exits:
                        edges[idx].append(current_node_index)
                
                # The 'false' path of the last condition (if no 'else')
                # also exits the chain.
                if last_condition_node is not None:
                    chain_exit_nodes.append(last_condition_node)
                
                prev_statement_exits = chain_exit_nodes
                
                if block_entry_node is None:
                    block_entry_node = current_node_index
                
                continue  # Skip i += 1 at end of loop

            # 4. Handle 'for' loops
            elif ln.startswith("for("):
                header_node = _add_node(ln)
                current_node_index = header_node
                
                # Find body and recurse
                body_start_idx = _find_body_start(lines, i)
                (
                    body_entry,
                    body_exits,
                    body_end_idx,
                ) = _parse_block(body_start_idx, stop_on_brace=True)

                if body_entry is not None:
                    # Rule: for connects to *inside* for loop
                    edges[header_node].append(body_entry)

                # Rule: inside for block last statement... connect to for loop
                for exit_idx in body_exits:
                    edges[exit_idx].append(header_node)

                # Connect previous statement to this 'for' header
                for idx in prev_statement_exits:
                    edges[idx].append(current_node_index)

                # Rule: for loop... connect to... *outside* for loop
                # The header node itself is the exit path (when cond is false)
                prev_statement_exits = [header_node]
                
                if block_entry_node is None:
                    block_entry_node = current_node_index

                i = body_end_idx + 1  # Move past '}'
                continue

            # 5. Handle plain assignment statements
            
            # --- FIX 1 ---
            # Added 'and ln != "END"' to ignore the "END" from the input text
            elif not ln.startswith("}") and ln != "END":
                assign_node = _add_node(ln)
                current_node_index = assign_node

                # Connect previous statement to this one
                for idx in prev_statement_exits:
                    edges[idx].append(current_node_index)

                prev_statement_exits = [current_node_index]
                
                if block_entry_node is None:
                    block_entry_node = current_node_index

            # 6. Move to next line
            i += 1

        return block_entry_node, prev_statement_exits, i

    # --- Main execution of build_cfg ---

    # Start parsing from line 0, don't stop on braces
    (entry_node, final_exit_nodes) = _parse_block(0, stop_on_brace=False)[:2]

    # --- FIX 2 ---
    # This block is now un-commented and active.
    # It adds the single, virtual "END" node that all final paths connect to.
    end_node = _add_node("END")
    for idx in final_exit_nodes:
        edges[idx].append(end_node)

    # Ensure all nodes have an entry in the edges dict
    for i in range(len(node_dict)):
        if i not in edges:
            edges[i] = []

    return node_dict, edges

# ---------------------------------------------------------------------
# Step 4: Dataset creation — saving to CSV
# ---------------------------------------------------------------------

def save_dataset_to_csv(codes: List[str], labels_list: List[list[int]], filename="data.csv"):
    """
    Save generated dataset to CSV.
    Each row: [code_str, labels]
    """
    with open(filename, mode="w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["code_str", "labels"])
        for code, labels in zip(codes, labels_list):
            writer.writerow([code, labels])
    print(f"✅ Dataset saved to {filename} (total {len(codes)} samples)")


# ---------------------------------------------------------------------
# Step 5: Main demo — end-to-end generation and saving
# ---------------------------------------------------------------------

if __name__ == "__main__":
    # Generate 5000 random samples across 4 programmer personalities
    codes, labels_list = generate_codes(n=5000)

    # Build CFG for the first sample (demo only)
    sample_code ="""for(int i=0; i<2; i++) {
  x = 1
  for(int j=0; j<3; j++) {
    y = 2
  }
  z = 3
}
k = 4
END
    """
    node_dict, adj_list = build_cfg(sample_code)

    print("Sample Generated Code:\n----------------------")
    print(sample_code, "\n")

    print("Node Dictionary:")
    for k, v in node_dict.items():
        print(f"  {k}: {v}")
    print("\nAdjacency List:")
    for k, v in adj_list.items():
        print(f"  {k} -> {v}")

    # Save dataset
    save_dataset_to_csv(codes, labels_list)